================================================================================
PR REVIEW AGENT - COMPREHENSIVE CODE ANALYSIS RULES DOCUMENTATION
================================================================================
Generated: December 10, 2025
Repository: https://github.com/bsimulator/pr-review-agent
================================================================================

TABLE OF CONTENTS
================================================================================
1. OVERVIEW
2. JAVA ANALYZER RULES (60+ RULES)
3. REACT ANALYZER RULES (30+ RULES)
4. ADVANCED JAVA RULES (NOT YET IMPLEMENTED)
5. IMPLEMENTATION STATUS
6. SEVERITY LEVELS
7. USAGE GUIDE

================================================================================
1. OVERVIEW
================================================================================

The PR Review Agent provides comprehensive code quality analysis with:
- 60+ implemented rules across Java and React
- 12+ advanced Java rules for future implementation
- 3 severity levels: Error (üî¥), Warning (‚ö†Ô∏è), Info (‚ÑπÔ∏è)
- Automated PR comment generation
- Git-based file detection
- Actionable suggestions for each violation

Total Rules Documented: 90+ rules

================================================================================
2. JAVA ANALYZER RULES (60+ RULES)
================================================================================

TIER 1: CRITICAL SECURITY & QUALITY ISSUES (17 RULES)
------------------------------------------------------------------------

Rule #1: System.out/err.println (USE_LOGGING_FRAMEWORK)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: System.out.println() or System.err.println()
  Issue: System output calls pollute logs and are hard to control
  Solution: Use SLF4J, Log4j, or Spring logging framework
  Example: System.out.println("Debug") ‚Üí logger.debug("Debug")

Rule #2: Empty catch blocks (EMPTY_CATCH_BLOCK)
  Severity: üî¥ ERROR
  Trigger: catch (Exception e) { }
  Issue: Exceptions are silently ignored, hiding bugs
  Solution: Add error handling or at least log the exception
  Example: 
    BAD:  catch (IOException e) { }
    GOOD: catch (IOException e) { logger.error("Failed to read", e); }

Rule #3: TODO without description (INCOMPLETE_TODO)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: // TODO without text after
  Issue: Incomplete task markers without context
  Solution: Add clear description of what needs to be done
  Example:
    BAD:  // TODO
    GOOD: // TODO: Implement pagination for large datasets

Rule #4: Magic numbers (MAGIC_NUMBER)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: Hardcoded numeric values > 3 digits
  Issue: Unexplained numbers make code harder to understand and maintain
  Solution: Extract to named constant
  Example:
    BAD:  if (count > 1000) { ... }
    GOOD: private static final int MAX_ITEMS = 1000;
          if (count > MAX_ITEMS) { ... }

Rule #5: Missing access modifiers (MISSING_ACCESS_MODIFIER)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: class definition without public/private/protected
  Issue: Package-private by default can be confusing
  Solution: Add explicit access modifier
  Example:
    BAD:  class UserService { }
    GOOD: public class UserService { }

Rule #6: Long lines (LONG_LINE)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Lines > 120 characters
  Issue: Long lines reduce readability and are hard to review
  Solution: Break into multiple lines
  Example: Long method chains should be split across lines

Rule #7: Thread.sleep usage (THREAD_SLEEP)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: Thread.sleep() call
  Issue: Blocks thread, impacts scalability and responsiveness
  Solution: Use scheduled executors or other async patterns
  Example:
    BAD:  Thread.sleep(5000);
    GOOD: scheduler.schedule(() -> doWork(), 5, TimeUnit.SECONDS);

Rule #8: Hardcoded secrets (HARDCODED_SECRET)
  Severity: üî¥ ERROR
  Trigger: password=, secret=, token=, api_key=, private_key= (in quotes)
  Issue: Credentials exposed in source code, security risk
  Solution: Use environment variables, .env, or secure vaults
  Example:
    BAD:  String apiKey = "sk-abc123def456";
    GOOD: String apiKey = System.getenv("API_KEY");

Rule #9: Wildcard imports (WILDCARD_IMPORT)
  Severity: üî¥ ERROR
  Trigger: import java.util.*;
  Issue: Makes it unclear which classes are used, causes naming conflicts
  Solution: Use explicit imports
  Example:
    BAD:  import java.util.*;
    GOOD: import java.util.List;
          import java.util.HashMap;

Rule #10: Missing JavaDoc on public methods (MISSING_JAVADOC)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: public method without /** */ comment above
  Issue: Public API undocumented, hard to use correctly
  Solution: Add JavaDoc with @param, @return, @throws
  Example:
    BAD:  public String calculateTotal(int a, int b) { ... }
    GOOD: /**
           * Calculates the total of two numbers
           * @param a first number
           * @param b second number
           * @return sum of a and b
           */
          public String calculateTotal(int a, int b) { ... }

Rule #11: Nested loops (NESTED_LOOPS)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: for loop inside another for/while loop
  Issue: O(n¬≤) complexity can cause performance issues
  Solution: Consider using streams or extracting to separate method
  Example:
    BAD:  for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) { ... }
          }
    GOOD: list.forEach(item -> 
            subitems.stream().filter(x -> x.equals(item)).forEach(...)
          )

Rule #12: SQL Injection risk (SQL_INJECTION_RISK)
  Severity: üî¥ ERROR
  Trigger: String concatenation with quotes in SQL query
  Issue: User input can modify SQL, massive security vulnerability
  Solution: Use PreparedStatement with ? placeholders
  Example:
    BAD:  String query = "SELECT * FROM users WHERE id = " + userId;
    GOOD: String query = "SELECT * FROM users WHERE id = ?";
          PreparedStatement stmt = conn.prepareStatement(query);
          stmt.setInt(1, userId);

Rule #13: Null pointer risk (NULL_POINTER_RISK)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: .toString(), .equals(), .length without null check
  Issue: NullPointerException will crash application
  Solution: Add null check before method call
  Example:
    BAD:  String result = user.toString();
    GOOD: String result = user != null ? user.toString() : "Unknown";

Rule #14: Hardcoded database URLs (HARDCODED_DATABASE_URL)
  Severity: üî¥ ERROR
  Trigger: jdbc/database/host/url with localhost, 127.0.0.1, 192.168
  Issue: Production code can't change database without recompile
  Solution: Use configuration files or environment variables
  Example:
    BAD:  String url = "jdbc:mysql://localhost:3306/mydb";
    GOOD: String url = System.getenv("DATABASE_URL");

Rule #15: Resource leak (RESOURCE_LEAK)
  Severity: üî¥ ERROR
  Trigger: FileInputStream, BufferedReader, Connection without close()
  Issue: Resources exhaustion, memory leaks
  Solution: Use try-with-resources statement
  Example:
    BAD:  FileInputStream fis = new FileInputStream("file.txt");
          byte[] data = fis.read();
    GOOD: try (FileInputStream fis = new FileInputStream("file.txt")) {
            byte[] data = fis.read();
          }

Rule #16: Log level misuse (LOG_LEVEL_MISUSE)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: log.debug/info with performance/timing/benchmark keywords
  Issue: Performance metrics should use proper metrics library
  Solution: Use Micrometer, Prometheus, or metrics framework
  Example:
    BAD:  log.debug("Request took " + duration + "ms");
    GOOD: metricsRegistry.timer("request.duration").record(duration);

Rule #17: Test coverage hint (TEST_COVERAGE_HINT)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Complex public method with multiple branches
  Issue: Complex logic should have unit tests
  Solution: Add unit tests for multiple code paths and edge cases
  Example: Methods with 3+ conditional branches need tests

------------------------------------------------------------------------
TIER 2: CODE QUALITY & BEST PRACTICES (13 RULES)
------------------------------------------------------------------------

Rule #18: Stream API opportunity (USE_STREAM_API)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Traditional for loop with filter/map patterns
  Issue: Traditional loops are verbose and error-prone
  Solution: Use .stream().filter().map().collect()
  Example:
    BAD:  List<String> names = new ArrayList<>();
          for (User user : users) {
            if (user.isActive()) {
              names.add(user.getName());
            }
          }
    GOOD: List<String> names = users.stream()
            .filter(User::isActive)
            .map(User::getName)
            .collect(Collectors.toList());

Rule #19: Generic exception handling (GENERIC_EXCEPTION)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: catch (Exception e)
  Issue: Too broad, catches unexpected errors and hides bugs
  Solution: Catch specific exceptions (IOException, SQLException)
  Example:
    BAD:  catch (Exception e) { handleError(e); }
    GOOD: catch (IOException e) { handleIOError(e); }
          catch (SQLException e) { handleDBError(e); }

Rule #20: Thread safety risk (THREAD_SAFETY_RISK)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: static private field without final/synchronized
  Issue: Mutable shared state across threads = race conditions
  Solution: Use synchronization, locks, or immutable data
  Example:
    BAD:  private static List<User> cache = new ArrayList<>();
    GOOD: private static final List<User> cache = 
            Collections.synchronizedList(new ArrayList<>());

Rule #21: Resource management (RESOURCE_MANAGEMENT)
  Severity: üî¥ ERROR
  Trigger: FileInputStream, Connection, Socket without try
  Issue: Resources not guaranteed to close on exceptions
  Solution: Use try-with-resources: try (Resource r = ...) { ... }
  Example:
    BAD:  Connection conn = DriverManager.getConnection(url);
          // If exception here, connection never closes
    GOOD: try (Connection conn = DriverManager.getConnection(url)) {
            // Safe - always closes
          }

Rule #22: Performance hotspot (PERFORMANCE_HOTSPOT)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: String concatenation with + in loops
  Issue: Creates new String objects each iteration, very slow
  Solution: Use StringBuilder
  Example:
    BAD:  String result = "";
          for (int i = 0; i < 1000; i++) {
            result = result + i + ",";
          }
    GOOD: StringBuilder sb = new StringBuilder();
          for (int i = 0; i < 1000; i++) {
            sb.append(i).append(",");
          }
          String result = sb.toString();

Rule #23: High cyclomatic complexity (HIGH_COMPLEXITY)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Multiple && and || operators (> 2)
  Issue: Complex logic is hard to understand and test
  Solution: Extract to separate method or use strategy pattern
  Example:
    BAD:  if (a > 0 && b > 0 && c > 0 && d > 0 && e < 100) { ... }
    GOOD: if (isValidInput(a, b, c, d, e)) { ... }

Rule #24: Unreachable code (UNREACHABLE_CODE)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: Code after return/throw statement
  Issue: Dead code suggests logic error
  Solution: Remove or reorganize control flow
  Example:
    BAD:  return result;
          System.out.println("Done"); // Never executes
    GOOD: return result; // Remove unreachable code

Rule #25: Naming convention (NAMING_CONVENTION)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Variable names with snake_case
  Issue: Inconsistent with Java conventions (camelCase)
  Solution: Use camelCase for variables
  Example:
    BAD:  int user_age = 25;
    GOOD: int userAge = 25;

Rule #26: Annotation placement (ANNOTATION_PLACEMENT)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: @Override not directly above method
  Issue: Annotation should be directly above method for clarity
  Solution: Place @Override directly above method signature
  Example:
    BAD:  @Override
          int i;
          public String getName() { ... }
    GOOD: @Override
          public String getName() { ... }

Rule #27: API design (API_DESIGN)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: parse() method without documentation
  Issue: Public parse methods should document format and exceptions
  Solution: Add JavaDoc with @throws for parsing failures
  Example: parse() methods need detailed documentation

Rule #28: Dead code detection (UNREACHABLE_CODE)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: Code after return that is not in else/switch
  Issue: Unreachable statements indicate logic error
  Solution: Review and remove dead code
  Example: Any code block unreachable due to returns

Rule #29: Complex initialization (N/A)
  Severity: ‚ÑπÔ∏è INFO
  Issue: Heavy static initializers can slow class loading
  Solution: Consider lazy loading patterns

Rule #30: Generic throws (THROWS_GENERIC_EXCEPTION)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: throws Exception in method signature
  Issue: Too broad, hides what exceptions are actually thrown
  Solution: Throw specific exceptions
  Example:
    BAD:  public void readFile() throws Exception { ... }
    GOOD: public void readFile() throws IOException { ... }

------------------------------------------------------------------------
BLOCK COMMENT ANALYSIS (5 ADDITIONAL RULES)
------------------------------------------------------------------------

Rule #31: Empty block comment (EMPTY_BLOCK_COMMENT)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: /* */ with no content
  Issue: Empty comments clutter code
  Solution: Remove or add meaningful content

Rule #32: Incomplete TODO in block (INCOMPLETE_TODO_BLOCK)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: /* TODO ... */ without description
  Issue: Incomplete task tracking
  Solution: Add assignee and deadline

Rule #33: FIXME comment (FIXME_COMMENT)
  Severity: üî¥ ERROR
  Trigger: /* FIXME ... */
  Issue: Blocking issue that should be resolved before production
  Solution: Create GitHub issue or resolve immediately

Rule #34: Temporary workaround (TEMPORARY_WORKAROUND)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: /* bug ... */ or /* hack ... */
  Issue: Temporary solutions should be tracked and refactored
  Solution: Document why and plan refactoring

Rule #35: Incomplete JavaDoc (INCOMPLETE_JAVADOC)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: /** ... */ without @param/@return/@throws tags
  Issue: Missing parameter/return documentation
  Solution: Add @param, @return, and @throws annotations

================================================================================
3. REACT ANALYZER RULES (30+ RULES)
================================================================================

TIER 1: CRITICAL REACT ISSUES (20 RULES)
------------------------------------------------------------------------

Rule #1: console.log statements (CONSOLE_LOG)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: console.log() calls
  Issue: Debug output left in production code
  Solution: Remove or use proper logging framework
  Example:
    BAD:  console.log('Component rendered');
    GOOD: import { logger } from './utils';
          logger.debug('Component rendered');

Rule #2: console.warn/error (CONSOLE_OUTPUT)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: console.warn(), console.error()
  Issue: Should use proper logging
  Solution: Use logging framework instead
  Example:
    BAD:  console.warn('Deprecated');
    GOOD: logger.warn('Deprecated');

Rule #3: Missing key prop in lists (MISSING_KEY_PROP)
  Severity: üî¥ ERROR
  Trigger: .map() without key prop in JSX
  Issue: React can't identify items, causes wrong updates
  Solution: Add unique key={item.id}
  Example:
    BAD:  {items.map(item => <Item name={item.name} />)}
    GOOD: {items.map(item => <Item key={item.id} name={item.name} />)}

Rule #4: Direct state mutation (DIRECT_STATE_MUTATION)
  Severity: üî¥ ERROR
  Trigger: state.x = value or setState without immutability
  Issue: React won't detect changes, UI won't update
  Solution: Use setState() or state setter functions
  Example:
    BAD:  this.state.count = 5; // Class component
          state.count = 5; // Hooks
    GOOD: this.setState({ count: 5 }); // Class
          setCount(5); // Hooks

Rule #5: Missing React import (MISSING_IMPORT)
  Severity: üî¥ ERROR
  Trigger: React hook used without import
  Issue: Hook not available, code crashes
  Solution: import { useState } from 'react'
  Example:
    BAD:  function App() {
            const [count, setCount] = useState(0);
          }
    GOOD: import { useState } from 'react';
          function App() {
            const [count, setCount] = useState(0);
          }

Rule #6: useEffect empty dependency array (EFFECT_RUNS_ONCE)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: useEffect(() => {...}, [])
  Issue: Effect only runs on mount - verify if intentional
  Solution: Add dependencies if effect should re-run
  Example:
    MAYBE OK: useEffect(() => { initializeApp(); }, [])
    LIKELY BUG: useEffect(() => { console.log(user); }, [])
                // Should be: }, [user])

Rule #7: Inline function definitions (INLINE_FUNCTION)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: onClick={() => ...} or onChange={() => ...}
  Issue: Function recreated on every render, performance issue
  Solution: Define outside JSX or use useCallback
  Example:
    BAD:  <button onClick={() => setCount(count + 1)}>
            Increment
          </button>
    GOOD: const handleClick = useCallback(() => {
            setCount(c => c + 1);
          }, []);
          <button onClick={handleClick}>Increment</button>

Rule #8: Missing prop types/TypeScript (MISSING_PROP_TYPES)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Component without TypeScript interface
  Issue: No type checking for props, errors at runtime
  Solution: Add TypeScript interface
  Example:
    BAD:  export function MyComponent(props) {
            return <div>{props.name}</div>;
          }
    GOOD: interface Props {
            name: string;
          }
          export function MyComponent({ name }: Props) {
            return <div>{name}</div>;
          }

Rule #9: Promise without error handling (MISSING_ERROR_HANDLING)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: .then() without .catch()
  Issue: Errors silently fail, UI shows nothing
  Solution: Add .catch() or use async/await with try-catch
  Example:
    BAD:  fetch('/api/data').then(res => setData(res));
    GOOD: fetch('/api/data')
            .then(res => setData(res))
            .catch(err => {
              console.error(err);
              setError(err.message);
            });

Rule #10: var keyword usage (USE_CONST_LET)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: var x = ...
  Issue: var has confusing scope rules, can be redeclared
  Solution: Use const (preferred) or let
  Example:
    BAD:  var count = 0;
    GOOD: const count = 0; // or let if reassignment needed

Rule #11: Long lines (LONG_LINE)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Lines > 100 characters
  Issue: Reduces readability, hard to review
  Solution: Break into multiple lines
  Example: Long JSX expressions should span lines

Rule #12: Hardcoded secrets (HARDCODED_SECRET)
  Severity: üî¥ ERROR
  Trigger: API keys, tokens, passwords in quotes
  Issue: Exposed in source code and built bundles
  Solution: Use environment variables
  Example:
    BAD:  const API_KEY = 'sk-abc123';
    GOOD: const API_KEY = process.env.REACT_APP_API_KEY;

Rule #13: Missing hook dependency array (MISSING_EFFECT_DEPENDENCY)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: useEffect without dependency array
  Issue: Effect runs on every render, infinite loops possible
  Solution: Add dependency array with all dependencies
  Example:
    BAD:  useEffect(() => {
            setData(calculateData());
          });
    GOOD: useEffect(() => {
            setData(calculateData());
          }, []);

Rule #14: Memory leak risk (MEMORY_LEAK_RISK)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: addEventListener without removeEventListener in cleanup
  Issue: Event listeners accumulate in memory
  Solution: Return cleanup function from useEffect
  Example:
    BAD:  useEffect(() => {
            window.addEventListener('scroll', handleScroll);
          }, []);
    GOOD: useEffect(() => {
            window.addEventListener('scroll', handleScroll);
            return () => {
              window.removeEventListener('scroll', handleScroll);
            };
          }, []);

Rule #15: Prop drilling (PROP_DRILLING)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: props.x.y or multiple levels of prop passing
  Issue: Components tightly coupled, hard to refactor
  Solution: Use Context API, Redux, or Zustand
  Example:
    BAD:  <Level1 user={user} />
          // Props passed through multiple components
    GOOD: <UserContext.Provider value={user}>
            <Level1 />
          </UserContext.Provider>

Rule #16: Large library imports (LARGE_LIBRARY_IMPORT)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: moment, lodash, underscore, jquery imports
  Issue: Large libraries impact bundle size
  Solution: Use smaller alternatives or tree-shaking versions
  Example:
    BAD:  import moment from 'moment';
    GOOD: import { format } from 'date-fns';
          // or
          import moment from 'moment-es6';

Rule #17: Accessibility missing (ACCESSIBILITY_MISSING)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: <button> or <div> with onClick without role/aria
  Issue: Not usable by screen readers, WCAG violation
  Solution: Add role and aria attributes
  Example:
    BAD:  <div onClick={handleClick}>Click me</div>
    GOOD: <button role="button" aria-label="Click to submit">
            Click me
          </button>

Rule #18: Missing alt text (MISSING_ALT_TEXT)
  Severity: üî¥ ERROR
  Trigger: <img> without alt attribute
  Issue: Image not described for screen readers, SEO issue
  Solution: Add descriptive alt text
  Example:
    BAD:  <img src="logo.png" />
    GOOD: <img src="logo.png" alt="Company logo" />

Rule #19: TypeScript coverage (TypeScript Coverage)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: .tsx file with untyped components
  Issue: No compile-time type checking
  Solution: Add TypeScript interfaces

Rule #20: Memoization opportunity (Memoization Hint)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Callback props without useMemo/useCallback
  Issue: Possible performance issue from re-renders
  Solution: Consider useMemo for values, useCallback for functions

------------------------------------------------------------------------
TIER 2: REACT BEST PRACTICES (10 RULES)
------------------------------------------------------------------------

Rule #21: useCallback opportunity (CONSIDER_USECALLBACK)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Handler functions defined in component
  Issue: Function recreated on each render, memoized child re-renders
  Solution: Wrap with useCallback
  Example:
    BAD:  const handleClick = (id) => { ... };
    GOOD: const handleClick = useCallback((id) => { ... }, []);

Rule #22: useMemo opportunity (CONSIDER_USEMEMO)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Heavy computations (filter, map, Math operations)
  Issue: Recomputed on every render, slow performance
  Solution: Wrap with useMemo
  Example:
    BAD:  const expensive = items.filter(...).map(...);
    GOOD: const expensive = useMemo(
            () => items.filter(...).map(...),
            [items]
          );

Rule #23: Dependency management (CHECK_PEER_DEPENDENCIES)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: Peer dependency imports
  Issue: Version compatibility issues
  Solution: Verify package.json has required versions
  Example: Check peerDependencies in library docs

Rule #24: Error boundary hint (CONSIDER_ERROR_BOUNDARY)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: try/catch patterns in components
  Issue: Error boundaries preferred for React
  Solution: Use Error Boundary component
  Example:
    <ErrorBoundary>
      <Component />
    </ErrorBoundary>

Rule #25: Custom hook naming (HOOK_NAMING)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Custom hook file not starting with 'use'
  Issue: Violates hook naming convention
  Solution: Prefix with 'use': useData, useAuth
  Example:
    BAD:  file: getData.ts
    GOOD: file: useGetData.ts

Rule #26: Complex state management (COMPLEX_STATE_MGMT)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Multiple useState calls (> 5)
  Issue: Hard to manage correlated state
  Solution: Consider useReducer for complex state
  Example:
    BAD:  const [name, setName] = useState('');
          const [email, setEmail] = useState('');
          const [age, setAge] = useState(0);
          // ... many more
    GOOD: const [state, dispatch] = useReducer(formReducer, initial);

Rule #27: CSS-in-JS inline styles (INLINE_STYLES)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: style={{ ... }} objects
  Issue: Styles recreated on each render
  Solution: Use CSS modules or styled-components
  Example:
    BAD:  <div style={{ color: 'red', fontSize: '16px' }}>
    GOOD: <div className={styles.container}>

Rule #28: Testing patterns (Testing Patterns)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Files with 'test' or 'spec' in name
  Issue: Test structure and coverage
  Solution: Follow testing best practices

Rule #29: SEO meta tags (MISSING_SEO_HEAD)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: Page components without Head/meta tags
  Issue: Missing SEO metadata
  Solution: Use Head component or Next.js Head
  Example:
    <Head>
      <title>Page Title</title>
      <meta name="description" content="..." />
    </Head>

Rule #30: Unused imports (UNUSED_IMPORT)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: import statement for unused symbol
  Issue: Clutters code and increases bundle size
  Solution: Remove unused import
  Example:
    BAD:  import { useState } from 'react';
          // useState never used in component
    GOOD: Remove the import

------------------------------------------------------------------------
BLOCK COMMENT ANALYSIS (5 ADDITIONAL RULES)
------------------------------------------------------------------------

Rule #31: Empty block comment (EMPTY_BLOCK_COMMENT)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: /* */ with no content
  Issue: Clutter, no value
  Solution: Remove empty comments

Rule #32: Incomplete TODO (INCOMPLETE_TODO_BLOCK)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: /* TODO ... */ without description
  Issue: Incomplete task tracking
  Solution: Add implementation details

Rule #33: FIXME comment (FIXME_COMMENT)
  Severity: üî¥ ERROR
  Trigger: /* FIXME ... */
  Issue: Blocking issue in production
  Solution: Resolve before deployment

Rule #34: Temporary workaround (TEMPORARY_WORKAROUND)
  Severity: ‚ö†Ô∏è WARNING
  Trigger: /* bug ... */ or /* hack ... */
  Issue: Should be refactored
  Solution: Plan and document refactoring

Rule #35: Missing JSDoc (MISSING_JSDOC_TAGS)
  Severity: ‚ÑπÔ∏è INFO
  Trigger: /* ... */ block without @param/@returns tags
  Issue: Undocumented parameters/returns
  Solution: Add JSDoc tags

================================================================================
4. ADVANCED JAVA RULES (NOT YET IMPLEMENTED)
================================================================================

CATEGORY 1: CONCURRENCY & THREAD SAFETY (8 RULES)
------------------------------------------------------------------------

Advanced Rule #1: Race condition detection
  Trigger: Unsynchronized access to shared mutable state
  Severity: üî¥ CRITICAL
  Issue: Multiple threads accessing same variable without sync
  Detection Challenge: Requires data flow analysis
  Implementation: ~Medium difficulty

Advanced Rule #2: Double-checked locking (DCL)
  Trigger: if (!initialized) { synchronized { if (!initialized) { ... } } }
  Severity: ‚ö†Ô∏è WARNING
  Issue: DCL pattern is broken in Java < 5, even with volatile
  Detection: Pattern matching for typical DCL code
  Implementation: ~Easy

Advanced Rule #3: Lock ordering violations
  Trigger: Acquiring locks in different order
  Severity: üî¥ CRITICAL
  Issue: Can cause deadlock
  Detection: Complex - requires lock tracking
  Implementation: ~Hard

Advanced Rule #4: Deadlock potential
  Trigger: Circular lock dependencies or synchronized methods calling other synchronized
  Severity: ‚ö†Ô∏è WARNING
  Issue: Can deadlock under load
  Detection: Call graph analysis
  Implementation: ~Hard

Advanced Rule #5: Volatile keyword misuse
  Trigger: volatile on non-primitive or used incorrectly
  Severity: ‚ö†Ô∏è WARNING
  Issue: Doesn't provide full synchronization
  Detection: Pattern matching
  Implementation: ~Medium

Advanced Rule #6: ThreadLocal memory leaks
  Trigger: ThreadLocal without remove() in cleanup
  Severity: ‚ö†Ô∏è WARNING
  Issue: In application servers, threads reused, data persists
  Detection: ThreadLocal usage without cleanup
  Implementation: ~Medium

Advanced Rule #7: Busy-wait loops
  Trigger: while (condition) { } or while (true) with sleep
  Severity: ‚ö†Ô∏è WARNING
  Issue: Wastes CPU, use wait/notify instead
  Detection: Pattern matching for busy loops
  Implementation: ~Easy

Advanced Rule #8: ConcurrentHashMap iteration issues
  Trigger: Iterating ConcurrentHashMap during modification
  Severity: ‚ö†Ô∏è WARNING
  Issue: May skip entries
  Detection: Usage pattern analysis
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 2: REFLECTION & SERIALIZATION (4 RULES)
------------------------------------------------------------------------

Advanced Rule #9: Unsafe reflection
  Trigger: setAccessible(true) on private fields/methods
  Severity: ‚ö†Ô∏è WARNING
  Issue: Breaks encapsulation, security risk
  Detection: Reflection API pattern matching
  Implementation: ~Easy

Advanced Rule #10: Unsafe deserialization
  Trigger: ObjectInputStream usage without validation
  Severity: üî¥ CRITICAL
  Issue: Can execute arbitrary code from untrusted data
  Detection: Pattern matching for ObjectInputStream
  Implementation: ~Medium

Advanced Rule #11: Missing serialVersionUID
  Trigger: Serializable class without serialVersionUID
  Severity: ‚ö†Ô∏è WARNING
  Issue: Version changes break deserialization
  Detection: Check for serialVersionUID field
  Implementation: ~Easy

Advanced Rule #12: Non-serializable fields in Serializable
  Trigger: Non-transient non-serializable field in Serializable class
  Severity: ‚ö†Ô∏è WARNING
  Issue: Will throw NotSerializableException
  Detection: Type checking on fields
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 3: STREAM & COLLECTION HANDLING (5 RULES)
------------------------------------------------------------------------

Advanced Rule #13: Unclosed streams
  Trigger: Stream created but not closed in try-with-resources
  Severity: ‚ö†Ô∏è WARNING
  Issue: Resource leak
  Detection: Similar to existing resource leak detection
  Implementation: ~Easy

Advanced Rule #14: Stream not terminated
  Trigger: .stream().filter(...).map(...) without terminal operation
  Severity: ‚ÑπÔ∏è INFO
  Issue: Stream lazy - nothing actually happens
  Detection: API call tracking
  Implementation: ~Medium

Advanced Rule #15: Parallel stream overhead
  Trigger: .parallelStream() on small datasets
  Severity: ‚ÑπÔ∏è INFO
  Issue: Overhead greater than benefit
  Detection: Pattern matching, heuristic on size
  Implementation: ~Medium

Advanced Rule #16: Iterator modification
  Trigger: Modifying collection during iteration
  Severity: üî¥ CRITICAL
  Issue: ConcurrentModificationException
  Detection: Complex - requires dataflow
  Implementation: ~Hard

Advanced Rule #17: Collecting into mutable collections
  Trigger: .collect(Collectors.toList()) then modifying
  Severity: ‚ö†Ô∏è WARNING
  Issue: Unintended side effects
  Detection: Usage pattern analysis
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 4: DEPENDENCY INJECTION & SPRING (5 RULES)
------------------------------------------------------------------------

Advanced Rule #18: Circular dependencies
  Trigger: @Autowired dependencies circular reference
  Severity: ‚ö†Ô∏è WARNING
  Issue: Spring can sometimes resolve, but indicates design issue
  Detection: Requires DI graph analysis
  Implementation: ~Hard

Advanced Rule #19: Missing @Transactional on public methods
  Trigger: Public method updating DB without @Transactional
  Severity: ‚ö†Ô∏è WARNING
  Issue: Changes not rolled back on exception
  Detection: DB access pattern + method visibility
  Implementation: ~Medium

Advanced Rule #20: Transaction scope violations
  Trigger: Lazy loading outside transaction, @Transactional on non-public
  Severity: ‚ö†Ô∏è WARNING
  Issue: LazyInitializationException or ignored transaction
  Detection: Spring proxy behavior analysis
  Implementation: ~Hard

Advanced Rule #21: Autowiring ambiguity
  Trigger: @Autowired with multiple beans of same type
  Severity: üî¥ ERROR
  Issue: Spring can't choose which bean to inject
  Detection: Type matching analysis
  Implementation: ~Medium

Advanced Rule #22: Bean lifecycle misuse
  Trigger: Using bean outside container or wrong scope
  Severity: ‚ö†Ô∏è WARNING
  Issue: Bean state inconsistent
  Detection: Scope annotation checking
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 5: MEMORY & RESOURCE MANAGEMENT (4 RULES)
------------------------------------------------------------------------

Advanced Rule #23: Large object allocation in loops
  Trigger: new Object() in tight loop
  Severity: ‚ö†Ô∏è WARNING
  Issue: Memory pressure, GC churn
  Detection: Object allocation pattern in loops
  Implementation: ~Medium

Advanced Rule #24: Unnecessary object cloning
  Trigger: .clone() when not needed
  Severity: ‚ÑπÔ∏è INFO
  Issue: Performance impact
  Detection: Pattern matching
  Implementation: ~Easy

Advanced Rule #25: String intern() misuse
  Trigger: String.intern() usage
  Severity: ‚ö†Ô∏è WARNING
  Issue: String pool can overflow, performance impact
  Detection: API call pattern matching
  Implementation: ~Easy

Advanced Rule #26: WeakReference/SoftReference misuse
  Trigger: Storing weak references without proper null checks
  Severity: ‚ö†Ô∏è WARNING
  Issue: Reference may be cleared unexpectedly
  Detection: Usage pattern analysis
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 6: DESIGN PATTERN VIOLATIONS (3 RULES)
------------------------------------------------------------------------

Advanced Rule #27: Immutability violation
  Trigger: Mutable default values in immutable class
  Severity: ‚ö†Ô∏è WARNING
  Issue: Breaks immutability contract
  Detection: Field mutability analysis
  Implementation: ~Medium

Advanced Rule #28: Singleton pattern issues
  Trigger: Singleton using reflection/cloning workarounds
  Severity: ‚ö†Ô∏è WARNING
  Issue: Can violate singleton contract
  Detection: Pattern matching
  Implementation: ~Easy

Advanced Rule #29: Builder pattern incomplete
  Trigger: Builder without build() or with required field setters
  Severity: ‚ÑπÔ∏è INFO
  Issue: Incomplete implementation
  Detection: Pattern matching
  Implementation: ~Easy

------------------------------------------------------------------------
CATEGORY 7: API & LIBRARY MISUSE (6 RULES)
------------------------------------------------------------------------

Advanced Rule #30: HashMap null safety
  Trigger: HashMap.get() result used without null check
  Severity: ‚ö†Ô∏è WARNING
  Issue: NullPointerException
  Detection: Method return tracking
  Implementation: ~Medium

Advanced Rule #31: SimpleDateFormat thread safety
  Trigger: static SimpleDateFormat or shared across threads
  Severity: üî¥ CRITICAL
  Issue: Date parsing errors in multithreaded code
  Detection: Static field + usage pattern
  Implementation: ~Medium

Advanced Rule #32: Regular expression DoS (ReDoS)
  Trigger: Complex regex patterns that can catastrophically backtrack
  Severity: üî¥ CRITICAL
  Issue: Can hang/crash on certain inputs
  Detection: Regex pattern analysis (heuristic)
  Implementation: ~Hard

Advanced Rule #33: XML XXE vulnerability
  Trigger: DocumentBuilder or SAXParser without XXE protection
  Severity: üî¥ CRITICAL
  Issue: XML External Entity attack
  Detection: Pattern matching for XML parsing
  Implementation: ~Medium

Advanced Rule #34: Comparator consistency
  Trigger: Comparator inconsistent with equals()
  Severity: ‚ö†Ô∏è WARNING
  Issue: TreeSet/TreeMap may have wrong ordering
  Detection: Interface implementation checking
  Implementation: ~Hard

Advanced Rule #35: NumberFormat thread safety
  Trigger: shared NumberFormat instance
  Severity: ‚ö†Ô∏è WARNING
  Issue: Parse/format errors in multithreaded code
  Detection: Static field pattern
  Implementation: ~Easy

------------------------------------------------------------------------
CATEGORY 8: SECURITY VULNERABILITIES (6 RULES)
------------------------------------------------------------------------

Advanced Rule #36: Command injection
  Trigger: Runtime.exec() or ProcessBuilder with string concatenation
  Severity: üî¥ CRITICAL
  Issue: Shell injection vulnerability
  Detection: API pattern matching with user input
  Implementation: ~Medium

Advanced Rule #37: Path traversal
  Trigger: File operations with user input without validation
  Severity: üî¥ CRITICAL
  Issue: Access files outside intended directory
  Detection: File API pattern + input validation checking
  Implementation: ~Medium

Advanced Rule #38: LDAP injection
  Trigger: LDAP queries with concatenated user input
  Severity: üî¥ CRITICAL
  Issue: LDAP filter injection
  Detection: LDAP API pattern matching
  Implementation: ~Medium

Advanced Rule #39: Insecure random
  Trigger: new Random() for security purposes
  Severity: üî¥ CRITICAL
  Issue: Random is predictable, use SecureRandom
  Detection: Random usage in security context (heuristic)
  Implementation: ~Medium

Advanced Rule #40: Weak cryptography
  Trigger: MD5, SHA-1, DES, RC4 usage
  Severity: üî¥ CRITICAL
  Issue: Known vulnerabilities, should use SHA-256+
  Detection: Cryptography algorithm pattern matching
  Implementation: ~Easy

------------------------------------------------------------------------
CATEGORY 9: DATA STRUCTURE & ALGORITHM ISSUES (4 RULES)
------------------------------------------------------------------------

Advanced Rule #41: O(n¬≤) algorithm detection
  Trigger: Nested loops with collection operations
  Severity: ‚ö†Ô∏è WARNING
  Issue: Poor scalability
  Detection: Loop nesting + complexity analysis
  Implementation: ~Medium

Advanced Rule #42: Inefficient list operations
  Trigger: ArrayList.remove() in loop
  Severity: ‚ö†Ô∏è WARNING
  Issue: O(n¬≤) due to shifting elements
  Detection: Pattern matching for remove in loops
  Implementation: ~Easy

Advanced Rule #43: Integer overflow
  Trigger: int arithmetic that can overflow
  Severity: ‚ö†Ô∏è WARNING
  Issue: Silent wraparound can cause bugs
  Detection: Arithmetic operation type analysis
  Implementation: ~Hard

Advanced Rule #44: Modulo on negative numbers
  Trigger: x % y where x might be negative
  Severity: ‚ÑπÔ∏è INFO
  Issue: Result can be negative (surprise!)
  Detection: Pattern matching + type analysis
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 10: TESTING & ASSERTION ISSUES (2 RULES)
------------------------------------------------------------------------

Advanced Rule #45: Assertions in production
  Trigger: assert statement without -ea flag enabled
  Severity: ‚ö†Ô∏è WARNING
  Issue: Assertions disabled in production by default
  Detection: assert statement pattern
  Implementation: ~Easy

Advanced Rule #46: Flaky tests
  Trigger: Tests with Thread.sleep() or timing dependencies
  Severity: ‚ÑπÔ∏è INFO
  Issue: Tests fail intermittently
  Detection: sleep() in test files, timing patterns
  Implementation: ~Medium

------------------------------------------------------------------------
CATEGORY 11: LOGGING & ERROR HANDLING (2 RULES)
------------------------------------------------------------------------

Advanced Rule #47: Logging in finally block
  Trigger: logging statement in finally block
  Severity: ‚ö†Ô∏è WARNING
  Issue: May suppress exceptions
  Detection: finally block pattern matching
  Implementation: ~Easy

Advanced Rule #48: Log injection vulnerability
  Trigger: User input logged directly
  Severity: ‚ö†Ô∏è WARNING
  Issue: Can inject malicious log entries
  Detection: User input + logging pattern
  Implementation: ~Hard

================================================================================
5. IMPLEMENTATION STATUS
================================================================================

COMPLETED: 60+ RULES
  ‚úÖ Java Analyzer: 30 rules
  ‚úÖ React Analyzer: 30 rules
  ‚úÖ Block comment analysis: 5 rules (Java), 5 rules (React)
  ‚úÖ Test suite with 55+ Java violations and 53+ React violations
  ‚úÖ Automated test runner

PLANNED FOR FUTURE PHASES:
  ‚è≥ Advanced Java rules: ~48 additional rules
  ‚è≥ Customizable severity levels
  ‚è≥ Rule profiles (strict, standard, lenient)
  ‚è≥ Performance metrics and statistics
  ‚è≥ IDE integration (VS Code, IntelliJ plugins)
  ‚è≥ Machine learning for pattern detection

DEPLOYMENT STATUS:
  ‚úÖ Deployed to GitHub: pr-review-agent
  ‚úÖ Deployed to test repository: baccarat_simulator
  ‚úÖ CI/CD integrated with GitHub Actions
  ‚úÖ Automated PR comments on violations

================================================================================
6. SEVERITY LEVELS EXPLAINED
================================================================================

üî¥ ERROR (Must Fix)
  - Security vulnerabilities (SQL injection, hardcoded secrets, XXE)
  - Critical runtime issues (direct state mutation, empty catch blocks)
  - Design violations (wildcard imports, missing key props)
  - Impact: Code will likely fail or expose security risk
  - Action: MUST be fixed before merge
  - Examples: SQL_INJECTION, HARDCODED_SECRET, DIRECT_STATE_MUTATION

‚ö†Ô∏è WARNING (Should Fix)
  - Performance issues (string concatenation in loops, magic numbers)
  - Code quality (missing JavaDoc, null pointer risks)
  - Best practices (Thread.sleep, generic exceptions)
  - Impact: May cause problems in production
  - Action: SHOULD be fixed, may be waived with justification
  - Examples: NULL_POINTER_RISK, PERFORMANCE_HOTSPOT, MAGIC_NUMBER

‚ÑπÔ∏è INFO (Nice to Have)
  - Suggestions for improvement (long lines, complexity)
  - Optimization opportunities (stream API, memoization)
  - Documentation hints (naming conventions, testing)
  - Impact: Code works, but could be better
  - Action: NICE to fix, low priority
  - Examples: HIGH_COMPLEXITY, USE_STREAM_API, NAMING_CONVENTION

================================================================================
7. USAGE GUIDE
================================================================================

RUNNING LOCALLY:

  1. Install dependencies:
     cd agent
     npm install

  2. Run analyzer on a file:
     node test-analyzers.js

  3. View all rules:
     cat ANALYZER_RULES.md (this file)

AUTOMATED PR CHECKS:

  The analyzer runs automatically on all PRs:
  1. PR opened/updated
  2. GitHub Actions workflow triggered
  3. Changed files identified via git diff
  4. Java/React analyzers process files
  5. Results posted as PR comment
  6. Grouped by severity and rule category

INTERPRETING RESULTS:

  Example output:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ üî¥ CRITICAL ISSUES: 3                       ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ [SQL_INJECTION] Line 45: Concatenation      ‚îÇ
  ‚îÇ   ‚Üí Use PreparedStatement with ?            ‚îÇ
  ‚îÇ                                             ‚îÇ
  ‚îÇ [HARDCODED_SECRET] Line 23: API key found   ‚îÇ
  ‚îÇ   ‚Üí Use environment variables               ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

CUSTOMIZING RULES:

  To adjust severity or detection:
  1. Edit javaAnalyzer.js or reactAnalyzer.js
  2. Modify regex patterns or thresholds
  3. Change severity levels
  4. Run tests to verify

EXAMPLE CUSTOMIZATIONS:

  // Change long line threshold (default 120)
  if (line.length > 100) { // Changed from 120 to 100
    issues.push({ rule: 'LONG_LINE', ... })
  }

  // Disable a rule by commenting out
  /*
  if (line.includes('magic')) {
    issues.push(...)
  }
  */

  // Change severity
  issues.push({
    severity: 'error', // Changed from 'warning'
    ...
  })

INTEGRATION WITH IDE:

  VS Code: Install ESLint + custom rules
  IntelliJ: Import as custom inspections
  Jenkins: Add to build pipeline

CONTINUOUS IMPROVEMENT:

  1. Review reported violations
  2. Identify patterns in your codebase
  3. Suggest new rules if gaps found
  4. Contribute back to project
  5. Share with team for consistency

================================================================================

DOCUMENT SUMMARY:

Total Rules Documented:        108 rules
  - Implemented Java Rules:      30 rules
  - Implemented React Rules:     30 rules  
  - Block Comment Rules:         10 rules (5 Java + 5 React)
  - Advanced Java Rules:         48 rules (not yet implemented)

Coverage by Category:
  - Security:                     15 rules
  - Performance:                  18 rules
  - Code Quality:                 35 rules
  - Best Practices:               25 rules
  - Design Patterns:              15 rules

Repository: https://github.com/bsimulator/pr-review-agent
Last Updated: December 10, 2025

================================================================================
